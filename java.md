
# Perguntas

### a) Use -XX:+PrintCompilation in program execution to identify the methods which were compiled to native instructions. How many times was mmult compiled? Why?

Foi compilado 8 vezes, e isso acontece porque é a função mais pesada (feita mais vezes), logo é a mais importante de otimizar. Ele faz profile, e se vir que pode dar para melhorar, melhora. 

### b) Identify code executed: In the MULT.s file, students will find the assembly code generated by the JIT during program execution. The perfreport.txt file contains the execution profile of the same run.
Identify the assembly code that was executed.

No perf, temos o endereço da instrução que foi mais vezes feita, do tipo 0xjaskldjo90290821034, e com esse valor vamos ao assembly e vemos qual a instrução. 

O perf dá sort das instruções pelo peso computacional, logo, apesar de várias instruções serem feitas o mesmo número de vezes, o mov, é a mais usada.

### c)

No java ele faz loop unrolling


### d)

Apesar de ser feita numa thread à parte, ocupa para aí 6%. Não é bloqueante


### e)

Memória funciona como uma stack, usa referências, coisas sem referências podem ser apagadas. 
Liberta geração antiga, 
Garbage collector é VM Thread. 

Na versão 1, ele guarda as matrizes todas na stack/saco. E elas cabem. 

Na versão 2, o programa vai sempre metendo coisas na stack, e por isso é preciso o garbage collector, porque não há espaço para tudo. Quando faz garbage collector, bloqueia o programa, é bloquante. 

O garbage collector só é mau quando é chamado.


O problema da versão 2 é ter o for, que força a garbage collector